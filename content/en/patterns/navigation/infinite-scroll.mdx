---
description: "Loads additional content automatically as users scroll down."
icon: Infinity
status: complete
---

import { BrowserSupport } from "@app/_components/browser-support";
import { BuildEffort } from "@app/_components/build-effort";
import { Callout } from "nextra/components";

# Infinite scroll

**_(Also called Continuous scrolling)_**

## Overview

**Infinite Scroll** is a UI pattern that dynamically loads more content as users scroll down a page, eliminating the need for pagination or manual interaction. It provides a seamless browsing experience by continuously appending new items to the current view.

This pattern is commonly used in **social media feeds, search results, and content-heavy websites** to keep users engaged without interruptions.

<BuildEffort
  level="high"
  description="Needs lazy loading, API handling, memory management, and edge cases like scrolling position retention."
/>

## Use Cases

### When to use:

Use Infinite Scroll when you need to dynamically load more content as users scroll without requiring manual pagination.

**Common scenarios include:**

- **Social media feeds** – e.g., Twitter, Instagram, Facebook, where users consume an endless stream of content.
- **News and blog sites** – e.g., showing a continuous stream of articles.
- **E-commerce product listings** – e.g., dynamically loading more items as users explore the catalog.
- **Search results** – e.g., reducing friction in discovering relevant items.
- **Media galleries** – e.g., loading more images/videos as users scroll.

### When not to use:

- **When users need to find specific content quickly** – Paginated results may be more efficient.
- **For structured navigation** – If users need to compare items or revisit previous results, pagination provides better control.
- **If performance is a concern** – Infinite scroll can lead to high memory usage and slow rendering.
- **For content requiring user actions** – If users frequently need to interact with elements (e.g., filling forms), infinite scrolling can be disruptive.
- **When reaching the footer is important** – Users may struggle to access footer content if new items keep loading.

## Benefits

- **Enhances engagement** by providing a seamless browsing experience.
- **Eliminates unnecessary page loads** and reduces navigation friction.
- **Encourages content exploration** by presenting an uninterrupted flow of items.
- **Optimized for touchscreens** where scrolling is more intuitive than clicking pagination buttons.

## Drawbacks

- **Navigation challenges** – Users may struggle to return to a previous position.
- **Performance issues** – Excessive DOM elements can lead to lag and slow rendering.
- **Accessibility concerns** – Keyboard and screen reader users may find it harder to navigate.
- **Disrupts footer visibility** – Users may never reach the footer if content loads indefinitely.

## Best Practices

### Content & Usability

**Do's ✅**

- **Provide clear loading indicators** to inform users that content is being fetched.
- **Use a ‘Load More’ button as a fallback** in case auto-loading fails.
- **Allow users to jump back to the top** with a ‘Back to Top’ button.
- **Save scroll position** so users don’t lose their place when navigating back.

**Don'ts ❌**

- **Avoid infinite loops** – Ensure loading stops when all content is fetched.
- **Don’t break browser back navigation** – Users should be able to return to previous content states.
- **Avoid excessive memory usage** – Remove off-screen items if necessary to optimize performance.

### Accessibility

**Do's ✅**

- **Ensure content is focusable** – New items should be reachable via keyboard navigation.
- **Announce new content dynamically** using ARIA live regions (`aria-live="polite"`).
- **Provide an alternative to infinite scrolling** – Offer pagination or a "Load More" option.
- **Ensure users can pause or stop loading** – Unexpected content updates can be disorienting.

**Don'ts ❌**

- **Avoid relying solely on scrolling** – Users with assistive technologies may need alternative navigation.
- **Don’t change content order unexpectedly** – Screen readers should process content sequentially.

### Visual Design

**Do's ✅**

- **Use smooth transitions** when loading new items to maintain a natural experience.
- **Indicate loading state** – Provide a spinner or skeleton loader while fetching data.
- **Ensure visual continuity** – Keep layout stable to prevent sudden jumps.

**Don'ts ❌**

- **Don’t push content down unexpectedly** – New items should append seamlessly without disrupting user flow.
- **Avoid excessive whitespace** – Content should remain readable and well-structured.

### Performance Optimization

**Do's ✅**

- **Implement lazy loading** – Load images and assets only when needed.
- **Use virtualization** – Remove off-screen items from the DOM to improve performance.
- **Optimize API calls** – Fetch only necessary data to reduce network requests.

**Don'ts ❌**

- **Avoid fetching too much data at once** – This can slow down rendering and increase memory usage.
- **Don’t re-render the entire list on new data arrival** – Only update necessary elements.

## SEO Considerations

- Ensure **search engines can access all content** by implementing **server-side rendering (SSR)** or an accessible paginated alternative.
- Provide a **static link to all content pages** to ensure crawlers can index them.
- Ensure that critical content is **available without JavaScript**.

## Testing Guidelines

### Functional Testing

**Should ✓**

- [ ] Confirm new content loads properly as the user scrolls.
- [ ] Ensure scroll position remains stable after navigating back to the page.
- [ ] Verify that users can manually load more content if needed.
- [ ] Ensure the feature works across different browsers and devices.

### Accessibility Testing

**Should ✓**

- [ ] Verify that screen readers announce new content properly.
- [ ] Ensure that keyboard users can navigate through dynamically loaded items.
- [ ] Test with reduced motion settings to ensure animations don’t cause issues.

### Performance Testing

**Should ✓**

- [ ] Measure memory usage to prevent excessive DOM elements.
- [ ] Ensure API calls are efficient and minimize network overhead.
- [ ] Test scrolling performance on both desktop and mobile devices.

## Related Patterns

- [Pagination](/patterns/navigation/pagination) – A structured alternative to infinite scrolling.
- [Back to Top](/patterns/navigation/back-to-top) – Helps users quickly return to the top of the page.

## Resources

### Articles

### Documentation

### Libraries
